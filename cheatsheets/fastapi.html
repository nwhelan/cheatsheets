<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fastapi Cheat Sheet</title>
  <link rel="stylesheet" href="../styles/cheatsheet.css">
  <!-- Prism.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
</head>
<body>
  <div class="cheatsheet-container">
<h1>FastAPI Quick Reference</h1>
<h2>Installation &amp; Setup</h2>
<h3>Install</h3>
<pre><code class="language-bash">pip install &quot;fastapi[standard]&quot;
# Includes uvicorn and other standard dependencies
</code></pre>
<h3>Basic App</h3>
<pre><code class="language-python">from fastapi import FastAPI

app = FastAPI()

@app.get(&quot;/&quot;)
async def read_root():
    return {&quot;Hello&quot;: &quot;World&quot;}
</code></pre>
<h3>Run Server</h3>
<pre><code class="language-bash">uvicorn main:app --reload
# main = filename, app = FastAPI instance
# --reload for development
</code></pre>
<h3>Access</h3>
<ul>
<li>API: <code>http://localhost:8000</code></li>
<li>Docs: <code>http://localhost:8000/docs</code></li>
<li>ReDoc: <code>http://localhost:8000/redoc</code></li>
</ul>
<h2>Path Operations</h2>
<h3>HTTP Methods</h3>
<p>Define different HTTP methods to perform CRUD operations on your resources.</p>
<pre><code class="language-python">@app.get(&quot;/items&quot;)
async def read_items():
    return [{&quot;item&quot;: &quot;foo&quot;}]

@app.post(&quot;/items&quot;)
async def create_item(item: Item):
    return item

@app.put(&quot;/items/{item_id}&quot;)
async def update_item(item_id: int, item: Item):
    return {&quot;id&quot;: item_id, **item.model_dump()}

@app.delete(&quot;/items/{item_id}&quot;)
async def delete_item(item_id: int):
    return {&quot;deleted&quot;: item_id}

@app.patch(&quot;/items/{item_id}&quot;)
async def partial_update(item_id: int, item: dict):
    return {&quot;id&quot;: item_id, **item}
</code></pre>
<h3>Path Parameters</h3>
<p>Extract dynamic values from the URL path with automatic type validation.</p>
<pre><code class="language-python">@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id: int):
    return {&quot;item_id&quot;: item_id}

# Path parameter with type validation
@app.get(&quot;/users/{user_id}&quot;)
async def get_user(user_id: int):
    return {&quot;user_id&quot;: user_id}

# Enum path parameters
from enum import Enum

class ModelName(str, Enum):
    alexnet = &quot;alexnet&quot;
    resnet = &quot;resnet&quot;

@app.get(&quot;/models/{model_name}&quot;)
async def get_model(model_name: ModelName):
    return {&quot;model&quot;: model_name}
</code></pre>
<h3>Query Parameters</h3>
<p>Handle optional filters, pagination, and search parameters from the URL query string.</p>
<pre><code class="language-python">@app.get(&quot;/items/&quot;)
async def read_items(skip: int = 0, limit: int = 10):
    return {&quot;skip&quot;: skip, &quot;limit&quot;: limit}

# Optional parameters (Python 3.10+)
@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id: int, q: str | None = None):
    if q:
        return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}
    return {&quot;item_id&quot;: item_id}

# Boolean parameters
@app.get(&quot;/items/&quot;)
async def read_items(active: bool = True):
    return {&quot;active&quot;: active}
</code></pre>
<h2>Request Body</h2>
<h3>Pydantic Models</h3>
<p>Accept and validate JSON data sent in POST/PUT requests.</p>
<pre><code class="language-python">from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.post(&quot;/items/&quot;)
async def create_item(item: Item):
    return item
</code></pre>
<h3>Model with Validation</h3>
<p>Add constraints to ensure data meets business rules before processing.</p>
<pre><code class="language-python">from pydantic import BaseModel, Field

class Item(BaseModel):
    name: str = Field(..., min_length=3)
    price: float = Field(..., gt=0)
    tax: float | None = Field(None, ge=0)

@app.post(&quot;/items/&quot;)
async def create_item(item: Item):
    return item
</code></pre>
<h3>Nested Models</h3>
<p>Structure complex data with embedded objects and lists.</p>
<pre><code class="language-python">class Image(BaseModel):
    url: str
    name: str

class Item(BaseModel):
    name: str
    image: Image | None = None
    tags: list[str] = []

@app.post(&quot;/items/&quot;)
async def create_item(item: Item):
    return item
</code></pre>
<h2>Response Models</h2>
<p>Control what data is returned to clients, filtering out sensitive fields.</p>
<h3>Response Model</h3>
<pre><code class="language-python">class UserIn(BaseModel):
    username: str
    password: str
    email: str

class UserOut(BaseModel):
    username: str
    email: str

@app.post(&quot;/users/&quot;, response_model=UserOut)
async def create_user(user: UserIn) -&gt; UserOut:
    return user  # password filtered out
</code></pre>
<h3>Status Codes</h3>
<p>Return appropriate HTTP status codes to indicate operation results.</p>
<pre><code class="language-python">from fastapi import status

@app.post(&quot;/items/&quot;, status_code=status.HTTP_201_CREATED)
async def create_item(item: Item):
    return item

@app.delete(&quot;/items/{item_id}&quot;, status_code=status.HTTP_204_NO_CONTENT)
async def delete_item(item_id: int):
    return None
</code></pre>
<h3>Multiple Response Models</h3>
<p>Return different response types based on conditions using union types.</p>
<pre><code class="language-python">@app.get(&quot;/items/{item_id}&quot;, response_model=Item | Message)
async def read_item(item_id: int):
    if item_id == 0:
        return {&quot;message&quot;: &quot;Not found&quot;}
    return {&quot;name&quot;: &quot;Item&quot;, &quot;price&quot;: 10}
</code></pre>
<h2>Dependencies</h2>
<h3>Basic Dependency</h3>
<p>Reuse common logic across multiple endpoints without code duplication.</p>
<pre><code class="language-python">from fastapi import Depends

def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}

@app.get(&quot;/items/&quot;)
async def read_items(commons: dict = Depends(common_parameters)):
    return commons
</code></pre>
<h3>Class Dependencies</h3>
<p>Organize related dependencies into reusable classes for better structure.</p>
<pre><code class="language-python">class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get(&quot;/items/&quot;)
async def read_items(commons: CommonQueryParams = Depends()):
    return commons
</code></pre>
<h3>Database Dependency</h3>
<p>Manage database sessions with automatic cleanup using generator dependencies.</p>
<pre><code class="language-python">def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get(&quot;/users/&quot;)
async def read_users(db: Session = Depends(get_db)):
    return db.query(User).all()
</code></pre>
<h2>Authentication</h2>
<h3>OAuth2 Password Bearer</h3>
<p>Secure your API endpoints with token-based authentication.</p>
<pre><code class="language-python">from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)

@app.get(&quot;/users/me&quot;)
async def read_users_me(token: str = Depends(oauth2_scheme)):
    return {&quot;token&quot;: token}
</code></pre>
<h3>Login Endpoint</h3>
<p>Validate user credentials and issue access tokens.</p>
<pre><code class="language-python">from fastapi.security import OAuth2PasswordRequestForm

@app.post(&quot;/token&quot;)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail=&quot;Incorrect credentials&quot;)
    return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}
</code></pre>
<h3>JWT Tokens</h3>
<p>Create signed tokens with expiration for secure stateless authentication.</p>
<pre><code class="language-python">from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone

SECRET_KEY = &quot;your-secret-key&quot;
ALGORITHM = &quot;HS256&quot;

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({&quot;exp&quot;: expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
</code></pre>
<h2>Error Handling</h2>
<h3>HTTPException</h3>
<p>Return structured error responses with appropriate status codes and messages.</p>
<pre><code class="language-python">from fastapi import HTTPException

@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id: int):
    if item_id not in items:
        raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)
    return items[item_id]
</code></pre>
<h3>Custom Exception Handler</h3>
<p>Define custom error handling logic for specific exception types.</p>
<pre><code class="language-python">from fastapi import Request
from fastapi.responses import JSONResponse

class CustomException(Exception):
    def __init__(self, name: str):
        self.name = name

@app.exception_handler(CustomException)
async def custom_exception_handler(request: Request, exc: CustomException):
    return JSONResponse(
        status_code=418,
        content={&quot;message&quot;: f&quot;Oops! {exc.name} did something.&quot;}
    )
</code></pre>
<h2>Request Data</h2>
<h3>Headers</h3>
<p>Access different parts of the HTTP request beyond URL and body.</p>
<pre><code class="language-python">from fastapi import Header

@app.get(&quot;/items/&quot;)
async def read_items(user_agent: str | None = Header(None)):
    return {&quot;User-Agent&quot;: user_agent}
</code></pre>
<h3>Cookies</h3>
<p>Read browser cookies for session management and preferences.</p>
<pre><code class="language-python">from fastapi import Cookie

@app.get(&quot;/items/&quot;)
async def read_items(session_id: str | None = Cookie(None)):
    return {&quot;session_id&quot;: session_id}
</code></pre>
<h3>Form Data</h3>
<p>Accept HTML form submissions instead of JSON payloads.</p>
<pre><code class="language-python">from fastapi import Form

@app.post(&quot;/login/&quot;)
async def login(username: str = Form(...), password: str = Form(...)):
    return {&quot;username&quot;: username}
</code></pre>
<h3>File Upload</h3>
<p>Handle file uploads from multipart form data.</p>
<pre><code class="language-python">from fastapi import File, UploadFile

@app.post(&quot;/files/&quot;)
async def create_file(file: bytes = File(...)):
    return {&quot;file_size&quot;: len(file)}

@app.post(&quot;/uploadfile/&quot;)
async def create_upload_file(file: UploadFile):
    contents = await file.read()
    return {&quot;filename&quot;: file.filename, &quot;size&quot;: len(contents)}
</code></pre>
<h2>Background Tasks</h2>
<p>Run time-consuming operations after returning the response to avoid blocking.</p>
<pre><code class="language-python">from fastapi import BackgroundTasks

def write_log(message: str):
    with open(&quot;log.txt&quot;, &quot;a&quot;) as f:
        f.write(message)

@app.post(&quot;/send-notification/&quot;)
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_log, f&quot;Notification sent to {email}\n&quot;)
    return {&quot;message&quot;: &quot;Notification sent&quot;}
</code></pre>
<h2>Middleware</h2>
<p>Process requests and responses globally across all endpoints.</p>
<h3>CORS</h3>
<p>Enable cross-origin requests from browsers for frontend integration.</p>
<pre><code class="language-python">from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[&quot;*&quot;],
    allow_credentials=True,
    allow_methods=[&quot;*&quot;],
    allow_headers=[&quot;*&quot;],
)
</code></pre>
<h3>Custom Middleware</h3>
<p>Add custom logic that runs on every request and response.</p>
<pre><code class="language-python">@app.middleware(&quot;http&quot;)
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers[&quot;X-Process-Time&quot;] = str(process_time)
    return response
</code></pre>
<h2>WebSockets</h2>
<p>Enable real-time bidirectional communication with clients.</p>
<pre><code class="language-python">from fastapi import WebSocket

@app.websocket(&quot;/ws&quot;)
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f&quot;Message: {data}&quot;)
</code></pre>
<h2>Database Integration</h2>
<h3>SQLAlchemy Setup</h3>
<p>Connect to SQL databases with ORM for easy data persistence.</p>
<pre><code class="language-python">from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot;

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()
</code></pre>
<h3>Models</h3>
<p>Define database table structures using Python classes.</p>
<pre><code class="language-python">from sqlalchemy import Column, Integer, String

class User(Base):
    __tablename__ = &quot;users&quot;
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    name = Column(String)
</code></pre>
<h3>CRUD Operations</h3>
<p>Implement Create, Read, Update, Delete operations with database integration.</p>
<pre><code class="language-python">@app.post(&quot;/users/&quot;, response_model=UserOut)
async def create_user(user: UserIn, db: Session = Depends(get_db)):
    db_user = User(**user.model_dump())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.get(&quot;/users/&quot;, response_model=list[UserOut])
async def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    users = db.query(User).offset(skip).limit(limit).all()
    return users
</code></pre>
<h2>Testing</h2>
<h3>Test Setup</h3>
<p>Write automated tests for your API endpoints without running a server.</p>
<pre><code class="language-python">from fastapi.testclient import TestClient

client = TestClient(app)

def test_read_root():
    response = client.get(&quot;/&quot;)
    assert response.status_code == 200
    assert response.json() == {&quot;Hello&quot;: &quot;World&quot;}

def test_create_item():
    response = client.post(
        &quot;/items/&quot;,
        json={&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 10.5}
    )
    assert response.status_code == 200
    assert response.json()[&quot;name&quot;] == &quot;Foo&quot;
</code></pre>
<h2>Advanced Features</h2>
<p>Organize and scale your application with modular patterns.</p>
<h3>APIRouter</h3>
<p>Split large applications into multiple files with separate route modules.</p>
<pre><code class="language-python">from fastapi import APIRouter

router = APIRouter(prefix=&quot;/items&quot;, tags=[&quot;items&quot;])

@router.get(&quot;/&quot;)
async def read_items():
    return [{&quot;name&quot;: &quot;Item&quot;}]

app.include_router(router)
</code></pre>
<h3>Lifespan Events (Modern)</h3>
<p>Run initialization and cleanup code when the application starts and stops.</p>
<pre><code class="language-python">from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print(&quot;Starting up...&quot;)
    yield
    # Shutdown
    print(&quot;Shutting down...&quot;)

app = FastAPI(lifespan=lifespan)
</code></pre>
<h3>Custom Response</h3>
<p>Return different response types like HTML, files, or redirects instead of JSON.</p>
<pre><code class="language-python">from fastapi.responses import HTMLResponse, FileResponse, RedirectResponse

@app.get(&quot;/html&quot;, response_class=HTMLResponse)
async def get_html():
    return &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;

@app.get(&quot;/file&quot;)
async def get_file():
    return FileResponse(&quot;file.pdf&quot;)

@app.get(&quot;/redirect&quot;)
async def redirect():
    return RedirectResponse(url=&quot;/docs&quot;)
</code></pre>

  </div>

  <!-- Prism.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>
</html>